---
title: "R Notebook"
output: html_document
---
Librerías a utilizar
```{r, message=FALSE,warning=FALSE}
library(hopkins)
library(factoextra)
library(NbClust)
library(mice)
library(dplyr)
library(ggplot2)
library(heatmaply)
library(plotly)
library(reshape2)
library(ggcorrplot)
library(tidyverse)
library(ppclust)
library(cluster)
```
Funciones generales
```{r}
# Extraído de: https://community.rstudio.com/t/is-there-a-function-to-replace-outliers/85091/6
replaceOutliers <- function(c) {
  b <- boxplot(c, plot = FALSE)
  s1 <- c
  s1[which(c %in% b$out)] <- mean(c[which(! c %in% b$out)],na.rm=TRUE)
  return(s1)
}
```
Lectura del dataset
```{r, message=FALSE,warning=FALSE}
movies <- read.csv("movies.csv", stringsAsFactors = FALSE)
# Casteando los valores string a numérico
movies$castWomenAmount <- as.numeric(movies$castWomenAmount)
movies$castMenAmount <- as.numeric(movies$castMenAmount)
```
Variables cuantitativas
* budget
* revenue
* actorsPopularity
* popularity
* runtime
* genresAmount
* productionCoAmount
* productionCountriesAmount
* voteCount
* actorsAmount
* castWomenAmount
* castMenAmount


# Preprocesamiento de datos
Explique qué variables no aportan información a la generación de grupos y por qué. Describa con qué variables calculará los grupos.

Debido a que los algoritmos de clustering que se utilizarán realizan la agrupación por medio de la medición de distancias entre las observaciones, por lo tal, las variables cualitativas no aportan información a la generación de grupos. Por otro lado, debido a que el promedio de votos se ve afectada por la cantidad de personas que votaron, y esto puede ser solo una persona, se determina que no es una variable que objetivamente pueda brindar información significativa al agrupamiento de los datos.

### Preparación de variables
Si bien, dentro del dataset se cuenta con la popularidad de los actores, sin embargo al ser una lista, no proporciona información general de la popularidad del cast de la película, debido a esto, se trabajará con el promedio de la popularidad de los actores dentro de la película como la popularidad promedio del cast.
```{r, message=FALSE,warning=FALSE}
actors_popularity <- movies$actorsPopularity
actors_popularity <- gsub('|', ',', actors_popularity, fixed = TRUE)
actors_popularity <- as.list(strsplit(actors_popularity, ','))
actors_popularity <- lapply(actors_popularity, as.numeric)
cast_popularity <- sapply(actors_popularity, mean)
movies$actorsPopularity <- cast_popularity
movies <- movies %>% rename(castPopularity = actorsPopularity)
```

## Detección de valores perdidos
```{r}
md.pattern(movies, rotate.names = TRUE)
# Dejando únicamente los casos completos para poder trabajar el agrupamiento
movies <- movies[complete.cases(movies), ]
```
Durante el proceso de detección de valores perdidos, también se encontraron valores anómalos, como observaciones en las cuales el presupuesto dado para la película es de 0, sin embargo, aún así, está obtuvo ganancias. Debido a que se consideran como valores erróneos, se decidió eliminar dichas observaciones de los datos a utilizar en el agrupamiento
## Validación de datos
```{r}
movies <- movies %>% filter(budget!=0)
movies <- movies %>% filter(runtime!=0)
```
## Filtrado de outliers
Para el tratamiento de outliers, en lugar de eliminar las observaciones que cuentan con datos atípicos, una mejor práctica es imputar dichos datos con la media o mediana.
```{r}
useless <- c('id','video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg')
clean_movies <- movies[ , !(names(movies) %in% useless)]
columns <- names(clean_movies)
replace <- purrr::map_dfc(columns, ~replaceOutliers(movies[[.]]))
replace <- replace %>% set_names(columns)
for (x in columns){
  movies[, x] <- replace[, x]
}
```

```{r}
# NO EJECUTAR AL HACER KNIT, SOLO PARA PRUEBAS
# Debido a las diversas escalas de cada una de las variables, es necesario realizar un boxplot para cada una
# budget, revenue, runtime, castPopularity, popularity, voteCount, genresAmount, productionCoAmount, productionCountriesAmount, actorsAmount, castWomenAmount, castMenAmount
clean_movies <- movies[ , !(names(movies) %in% useless)]
boxplot(clean_movies$budget, horizontal = TRUE)
boxplot(clean_movies$revenue, horizontal = TRUE)
boxplot(clean_movies$runtime, horizontal = TRUE)
boxplot(clean_movies$castPopularity, horizontal = TRUE)
boxplot(clean_movies$popularity, horizontal = TRUE)
boxplot(clean_movies$voteCount, horizontal = TRUE)
boxplot(clean_movies$genresAmount, horizontal = TRUE)
boxplot(clean_movies$productionCoAmount, horizontal = TRUE)
boxplot(clean_movies$productionCountriesAmount, horizontal = TRUE)
boxplot(clean_movies$actorsAmount, horizontal = TRUE)
boxplot(clean_movies$castWomenAmount, horizontal = TRUE)
boxplot(clean_movies$castMenAmount, horizontal = TRUE)
```

## Correlación entre variables
```{r}
clean_movies <- movies[ , !(names(movies) %in% useless)]
correlation <- cor(clean_movies, method="kendall")
p.mat <- cor_pmat(clean_movies)
ggcorrplot(correlation, hc.order = TRUE, type = "lower",
   outline.col = "white",
   ggtheme = ggplot2::theme_gray,
   colors = c("#6D9EC1", "white", "#E46726"),
    lab = TRUE)

```
Con base en la correlación de las variables y para faciliar el procesos de agrupamiento y disminuir la dimensión de variables a agrupar, se sabe que se puede utilizar únicamente una de las variables correlacionadas. En este caso, las variables altamente correlacionadas son:
* Presupuesto con Ganancias
* Presupuesto con Cantidad de hombres en el cast
* Ganancias con Cantidad de votos
* Cantidad de actores con Cantidad de mujeres en el cast
* Cantidad de actores con Cantidad de hombres en el cast
Con base en lo anterior, se dejaran fuera las siguientes variables para el agrupamiento:
* Presupuesto
* Cantidad de hombres en el cast
* Cantidad de mujeres en el cast
* Cantidad de votos

## Estandarización de variables
Todas las características estén en un mismo rango de valores
```{r}
useless <- c('id','video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg', 'budget', 'castMenAmount', 'castWomenAmount', 'voteCount')
clean_movies <- movies[ , !(names(movies) %in% useless)]

data <- as.matrix(clean_movies)
barplot(data, beside = TRUE, main = 'Comparación de observaciones', las=2)
# Normalizar únicamente las variables númericas sin tener que crear otro df
movies <- mutate_if(movies, is.numeric, scale)
```
```{r}
# Gráfico luego de escalar los datos
clean_movies <- movies[ , !(names(movies) %in% useless)]
data <- as.matrix(clean_movies)
barplot(data, beside = TRUE, main = 'Comparación de observaciones', las=2)
```
## Análisis de la tendencia al agrupamiento
Utilice estadístico de Hopkings y la VAT (Visual Assessment of cluster Tendency). Discuta sus resultados e impresiones.
### Análisis de Hopkings
```{r}
hopkins(clean_movies)
```
Como se puede observar, el valor de hopkins es de 0.9968 por lo que, con base en la teoría, se puede inducir que dichos datos no cuentan con una distribución uniforme. Por otro lado, debido a que el estadístico de hopkins encontrado se encuentra alejado de 0.5 se puede inferir que los datos sí cuentan con tendencia al agrupamiento.

Para complementar el resultado obtenido por medio del estadístico de hopkins, se procede a realizar una evaluación visual de la tendencia, VAT, el cual calcula, mediante las distancias euclídeas, si los datos presentan algún indicio de agrupación.
```{r}
dist_movies <- clean_movies %>% dist()
fviz_dist(dist_movies, show_labels = F)
```
Como se puede observar, tanto en el estadístico de hopkins, como en el gráfico de VAT, los datos sí tienen cierta tendencia al agrupamiento, por lo tal, sí es viable aplicar algoritmos de agrupamiento.

## ¿Cuál es el número de grupos a formar para los datos?
Haga una gráfica de codo y explique la razón de la elección de la cantidad de clústeres con la que trabajará.
### Cantidad óptima de grupos según gráfica de codo
```{r, message=FALSE,warning=FALSE}
fviz_nbclust(clean_movies, kmeans, method = "wss") +
labs(subtitle = "Número óptimo de clusters elbow-method")
```
### Cantidad óptima de grupos según paquete NbClust
```{r}
groups <- NbClust(clean_movies, distance = "euclidean", min.nc = 2,
              max.nc = 10, method = "complete", index ="all")
```
Con base en la gráfica del codo, y en el cálculo del número de clusters por 30 algoritmos diferentes, se considera que la cantidad adecuada de agrupamiento de los datos es 3.

# Algoritmos de agrupamiento
## K-Medias
```{r}
km<-kmeans(clean_movies,3,iter.max =300)
#km
```
```{r}
fviz_cluster(km, data = clean_movies,geom = "point", ellipse.type = "norm")
```
## Fuzzy c-means
```{r}
fuzzy<-fcm(clean_movies,3,iter.max=300)
#fuzzy
```
```{r}
fuzzy2 <- ppclust2(fuzzy, "kmeans")
fviz_cluster(fuzzy2, data = clean_movies, 
  ellipse.type = "convex",
  palette = "jco",
  repel = TRUE)
```
## Mixture of gaussians
```{r mixture of gaussians}
mc<-Mclust(clean_movies,3)
summary(mc)
```
```{r cortando el dendrograma}
groups<-cutree(Hierar_cl,k=3) #corta el dendograma, determinando el grupo de cada fila
table(groups)
```
#### Silueta clustering jerárquico 
### Silueta para k-means
```{r silueta clustering jerarquico k-means}
silkm<-silhouette(km$cluster,dist(clean_movies))
mean(silkm[,3]) 
```
Vamos a graficar la silueta para visualizar los resultados de cada cluster  
```{r grafico de silueta clusterig jerarquico 1}
plot(silkm, cex.names=.4, col=1:3)
```
### Silueta para Hierarchical clustering
```{r silueta clustering jerarquico}
silhc<-silhouette(groups,dist(clean_movies))
mean(silhc[,3]) 
```
### Esto a veces funciona 
```{r grafico de silueta clusterig jerarquico 2} 
plot(silhc, cex.names=.4, col=1:3)
```
#### Silueta para mixture of gaussians  
```{r silueta de mezcla de gausianos}
clean_movies$mxGau<-mc$classification
silmg<-silhouette(mc$classification,dist(clean_movies))
mean(silmg[,3]) 
```
```{r grafico de la silueta mixture of gaussians}
plot(silmg, cex.names=.4, col=1:3)
```