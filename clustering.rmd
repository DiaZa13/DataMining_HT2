---
title: "R Notebook"
output: html_document
---
Librerias a utilizar
```{r}
library(hopkins)
library(factoextra)
library(NbClust)
library(mice)
library(dplyr)
library(ggplot2)
library(heatmaply)
library(plotly)
library(reshape2)
library(ggcorrplot)
```
Lectura del dataset
```{r}
movies <- read.csv("movies.csv", stringsAsFactors = FALSE)
# Casteando los valores string a numérico
movies$castWomenAmount <- as.numeric(movies$castWomenAmount)
movies$castMenAmount <- as.numeric(movies$castMenAmount)
```
Variables cuantitativas
* budget
* revenue
* actorsPopularity
* popularity
* runtime
* genresAmount
* productionCoAmount
* productionCountriesAmount
* voteCount
* actorsAmount
* castWomenAmount
* castMenAmount


# Preprocesamiento de datos
Explique qué variables no aportan información a la generación de grupos y por qué. Describa con qué variables calculará los grupos.

Debido a que los algoritmos de clustering que se utilizarán realizan la agrupación por medio de la medición de distancias entre las observaciones, por lo tal, las variables cualitativas no aportan información a la generación de grupos. Por otro lado, debido a que el promedio de votos se ve afectada por la cantidad de personas que votaron, y esto puede ser solo una persona, se determina que no es una variable que objetivamente pueda brindar información significativa al agrupamiento de los datos.

### Preparación de variables
Si bien, dentro del dataset se cuenta con la popularidad de los actores, sin embargo al ser una lista, no proporciona información general de la popularidad del cast de la película, debido a esto, se trabajará con el promedio de la popularidad de los actores dentro de la película como la popularidad promedio del cast.
```{r}
actors_popularity <- movies$actorsPopularity
actors_popularity <- gsub('|', ',', actors_popularity, fixed = TRUE)
actors_popularity <- as.list(strsplit(actors_popularity, ','))
actors_popularity <- lapply(actors_popularity, as.numeric)
cast_popularity <- sapply(actors_popularity, mean)
movies$actorsPopularity <- cast_popularity
movies <- movies %>% rename(castPopularity = actorsPopularity)
```

## Detección de valores perdidos
```{r}
md.pattern(movies, rotate.names = TRUE)
# Dejando únicamente los casos completos para poder trabajar el agrupamiento
movies <- movies[complete.cases(movies), ]
```
## Correlación entre variables
```{r}
cualitative <- c('id', 'video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg')
clean_movies <- movies[ , !(names(movies) %in% cualitative)]
correlation <- cor(clean_movies)
p.mat <- cor_pmat(clean_movies)
ggcorrplot(correlation, hc.order = TRUE, type = "lower",
   outline.col = "white",
   ggtheme = ggplot2::theme_gray,
   colors = c("#6D9EC1", "white", "#E46726"),
    lab = TRUE)


```
Con base en la correlación de las variables y para faciliar el procesos de agrupamiento y disminuir la dimensión de variables a agrupar, se sabe que se puede utilizar únicamente una de las variables correlacionadas. En este caso, las variables altamente correlacionadas son:
* Cantidad de actores con Cantidad de mujeres en el cast
* Inversión con Ganancias
* Ganancias con cantidad de votos
* Cantidad de países de producción con cantidad de hombres en el cast
Con base en lo anterior, para el agrupamiento se dejará fuera la cantidad de mujeres en el cast, la inversión, la cantidad de votos y la cantidad de hombres en el cast.

## Filtrado de outliers
```{r}
useless <- c('id', 'video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg', 'castWomenAmount', 'budget', 'voteCount', 'castMenAmount', )
clean_movies <- movies[ , !(names(movies) %in% cualitative)]
data <- melt(clean_movies)
ggplot(data, aes(x='variable', y='value')) + geom_boxplot()
```

## Estandarización de variables
Todas las características estén en un mismo rango de valores
```{r}
cualitative <- c('id', 'video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg')
clean_movies <- movies[ , !(names(movies) %in% cualitative)]
data <- as.matrix(clean_movies)
barplot(data, beside = TRUE, main = 'Comparación de observaciones', las=2)
# Normalizar únicamente las variables númericas sin tener que crear otro df
movies <- mutate_if(movies, is.numeric, scale)
```
```{r}
# Gráfico luego de escalar los datos
cualitative <- c('id', 'video', 'releaseDate','originalTitle', 'originalLanguage', 'title', 'homePage', 'director', 'genres', 'productionCompany', 'productionCompanyCountry', 'productionCountry', 'actors', 'actorsCharacter', 'voteAvg')
clean_movies <- movies[ , !(names(movies) %in% cualitative)]
data <- as.matrix(clean_movies)
barplot(data, beside = TRUE, main = 'Comparación de observaciones', las=2)
```
## Análisis de la tendencia al agrupamiento
Utilice estadístico de Hopkings y la VAT (Visual Assessment of cluster Tendency). Discuta sus resultados e impresiones.
### Análisis de Hopkings
```{r}
hopkins(clean_movies)
```
Como se puede observar, el valor de hopkins es de 0.9999 por lo que, con base en la teoría, se puede inducir que dichos datos no cuentan con una distribución uniforme. Por otro lado, debido a que el estadístico de hopkins encontrado se encuentra alejado de 0.5 se puede inferir que los datos sí cuentan con tendencia al agrupamiento.

Para verificar la veracidad del estadístico de hopkins encontrado, se procede a realizar una evaluación visual de la tendencia, VAT, el cual calcula, mediante las distancias euclídeas, si los datos presentan algún indicio de agrupación.
```{r}
dist_movies <- clean_movies %>% dist()
fviz_dist(dist_movies, show_labels = F)
```
Como se puede observar en el gráfico de VAT, los datos sí tienen cierta tendencia al agrupamiento, por lo tal, sí es viable aplicar algoritmos de agrupamiento.

## ¿Cuál es el número de grupos a formar para los datos?
Haga una gráfica de codo y explique la razón de la elección de la cantidad de clústeres con la que trabajará.
### Cantidad óptima de grupos según gráfica de codo
```{r}
fviz_nbclust(clean_movies, kmeans, method = "wss") +
labs(subtitle = "Número óptimo de clusters elbow-method")
```
### Cantidad óptima de grupos según método de la silueta promedio
```{r}
fviz_nbclust(clean_movies, kmeans, method = "silhouette")
```
### Cantidad óptima de grupos según el estadístico de brecha

```{r}
fviz_nbclust(clean_movies, kmeans, method = "gap_stat", nboot = 500,
             k.max = 15, verbose = FALSE, nstart = 50)
```
